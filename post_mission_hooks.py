#!/usr/bin/env python3
"""
Post-Mission Hooks - Automatic actions to run after successful mission completion.

This module provides hooks that execute after a mission completes successfully.
Currently implemented:
- Git commit hook: Commits dashboard_v2.py changes with mission ID reference
- Git sync hook: Pushes unpushed commits across all configured repos
"""

import subprocess
import logging
from pathlib import Path
from datetime import datetime
from typing import Optional, Dict, Any, List

logger = logging.getLogger(__name__)

# Files to track for automatic commits
DASHBOARD_FILES = [
    "dashboard_v2.py",
    "atlasforge_engine.py",
    "exploration_hooks.py",
    "mission_knowledge_base.py",
    "mission_analytics.py",
]

# Base directory for the AtlasForge project
AF_BASE_DIR = Path(__file__).parent


def git_auto_commit_dashboard(mission_id: str, mission_summary: Optional[str] = None) -> Dict[str, Any]:
    """
    Automatically commit dashboard-related file changes after a successful mission.

    Creates atomic commits with mission ID references to ensure all dashboard
    improvements are version-controlled and recoverable.

    Args:
        mission_id: The mission ID that caused the changes
        mission_summary: Optional summary of mission changes

    Returns:
        Dict with status and details of the commit operation
    """
    result = {
        "success": False,
        "mission_id": mission_id,
        "files_committed": [],
        "commit_hash": None,
        "message": None,
        "error": None
    }

    try:
        # Check if we're in a git repository
        git_check = subprocess.run(
            ["git", "rev-parse", "--git-dir"],
            cwd=AF_BASE_DIR,
            capture_output=True,
            text=True
        )

        if git_check.returncode != 0:
            result["error"] = "Not a git repository"
            result["message"] = "Skipped: Not in a git repository"
            return result

        # Get list of modified dashboard files
        status_result = subprocess.run(
            ["git", "status", "--porcelain"],
            cwd=AF_BASE_DIR,
            capture_output=True,
            text=True
        )

        if status_result.returncode != 0:
            result["error"] = f"git status failed: {status_result.stderr}"
            return result

        # Parse modified files
        modified_files = []
        for line in status_result.stdout.strip().split('\n'):
            if not line:
                continue
            # Status is first 2 chars, then space, then filename
            status_code = line[:2].strip()
            filename = line[3:].strip()

            # Check if it's a dashboard-related file that's been modified
            base_name = Path(filename).name
            if base_name in DASHBOARD_FILES and status_code in ('M', 'A', 'AM', ' M'):
                modified_files.append(filename)

        if not modified_files:
            result["success"] = True
            result["message"] = "No dashboard files modified"
            return result

        # Stage the modified dashboard files
        for f in modified_files:
            subprocess.run(
                ["git", "add", f],
                cwd=AF_BASE_DIR,
                capture_output=True
            )

        # Create commit message
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")

        if len(modified_files) == 1:
            files_desc = Path(modified_files[0]).name
        else:
            files_desc = f"{len(modified_files)} dashboard files"

        commit_msg_parts = [
            f"[Auto] Dashboard update from mission {mission_id}",
            "",
            f"Modified: {files_desc}",
            f"Timestamp: {timestamp}",
        ]

        if mission_summary:
            commit_msg_parts.extend(["", "Mission summary:", mission_summary[:500]])

        commit_msg_parts.extend([
            "",
            "Files changed:",
            *[f"  - {f}" for f in modified_files],
            "",
            "This commit was automatically generated by the AtlasForge post-mission hook.",
        ])

        commit_message = '\n'.join(commit_msg_parts)

        # Create the commit
        commit_result = subprocess.run(
            ["git", "commit", "-m", commit_message],
            cwd=AF_BASE_DIR,
            capture_output=True,
            text=True
        )

        if commit_result.returncode != 0:
            # Check if there's nothing to commit
            if "nothing to commit" in commit_result.stdout.lower() or \
               "nothing to commit" in commit_result.stderr.lower():
                result["success"] = True
                result["message"] = "No changes to commit (files already committed)"
                return result

            result["error"] = f"git commit failed: {commit_result.stderr}"
            return result

        # Get the commit hash
        hash_result = subprocess.run(
            ["git", "rev-parse", "--short", "HEAD"],
            cwd=AF_BASE_DIR,
            capture_output=True,
            text=True
        )

        result["success"] = True
        result["files_committed"] = modified_files
        result["commit_hash"] = hash_result.stdout.strip() if hash_result.returncode == 0 else "unknown"
        result["message"] = f"Committed {len(modified_files)} file(s) as {result['commit_hash']}"

        logger.info(f"Post-mission git commit: {result['message']}")

        return result

    except Exception as e:
        result["error"] = str(e)
        logger.error(f"Post-mission git commit failed: {e}")
        return result


def git_sync_on_complete(mission_id: str) -> Dict[str, Any]:
    """
    Sync all configured repos when a mission reaches COMPLETE stage.

    Pushes any unpushed commits across all repos with configured remotes.
    This ensures mission work is backed up to remote repositories.

    Args:
        mission_id: The completed mission ID

    Returns:
        Dict with sync results including repos pushed/failed counts
    """
    result = {
        "success": False,
        "mission_id": mission_id,
        "repos_checked": 0,
        "repos_pushed": 0,
        "repos_failed": 0,
        "repos_skipped": 0,
        "details": [],
        "message": None,
        "error": None
    }

    try:
        # Import sync scheduler
        from git_sync_scheduler import get_scheduler

        scheduler = get_scheduler()

        # Trigger mission complete sync
        report = scheduler.trigger_mission_complete_sync(mission_id)

        result["success"] = True
        result["repos_checked"] = report.repos_checked
        result["repos_pushed"] = report.repos_pushed
        result["repos_failed"] = report.repos_failed
        result["repos_skipped"] = report.repos_skipped

        # Collect details for each repo
        for r in report.results:
            result["details"].append({
                "repo_id": r.repo_id,
                "repo_name": r.repo_name,
                "status": r.status,
                "message": r.message,
                "pushed": r.pushed
            })

        if report.repos_pushed > 0:
            result["message"] = f"Pushed {report.repos_pushed} repo(s) successfully"
        elif report.repos_failed > 0:
            result["message"] = f"Sync completed with {report.repos_failed} failure(s)"
        else:
            result["message"] = "All repos up to date"

        logger.info(f"Post-mission sync for {mission_id}: {result['message']}")

    except ImportError as e:
        result["error"] = f"git_sync_scheduler not available: {e}"
        result["message"] = "Sync skipped - scheduler not available"
        logger.warning(result["error"])
    except Exception as e:
        result["error"] = str(e)
        result["message"] = f"Sync failed: {e}"
        logger.error(f"Post-mission sync failed: {e}")

    return result


def run_post_mission_hooks(mission: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Run all post-mission hooks after a successful mission completion.

    Args:
        mission: The completed mission dict

    Returns:
        List of hook results
    """
    results = []

    mission_id = mission.get("mission_id", "unknown")
    mission_summary = mission.get("problem_statement", "")[:200]

    # Run git auto-commit hook
    try:
        git_result = git_auto_commit_dashboard(mission_id, mission_summary)
        results.append({
            "hook": "git_auto_commit",
            **git_result
        })
    except Exception as e:
        logger.error(f"Git auto-commit hook failed: {e}")
        results.append({
            "hook": "git_auto_commit",
            "success": False,
            "error": str(e)
        })

    # Run git sync hook to push unpushed commits
    try:
        sync_result = git_sync_on_complete(mission_id)
        results.append({
            "hook": "git_sync",
            **sync_result
        })
    except Exception as e:
        logger.error(f"Git sync hook failed: {e}")
        results.append({
            "hook": "git_sync",
            "success": False,
            "error": str(e)
        })

    return results


# For testing
if __name__ == "__main__":
    import sys

    logging.basicConfig(level=logging.INFO)

    # Test with a mock mission ID
    test_mission_id = sys.argv[1] if len(sys.argv) > 1 else "test_mission_001"

    result = git_auto_commit_dashboard(test_mission_id, "Test mission summary")
    print(f"Result: {result}")
